#!/usr/bin/env python

# This script calculates the field generated by a z-polarised, x-propagating
# plane wave incident on a dielectric sphere.

# The parameters of the system are taken from A. Devilez et al., Opt. Express
# 16, 14200 (2008) and are chosen so as to make a photonic jet appear behind the
# sphere.

# Help Python find the bempp module
import sys
sys.path.append("..")

from bempp.lib import *
import numpy as np

# Parameters

epsInt = 1.2**2
epsExt = 1
muInt = 1
muExt = 1
kVacuum = 16
kExt = kVacuum * np.sqrt(epsExt * muExt)
kInt = kVacuum * np.sqrt(epsInt * muInt)
rho = (kInt * muExt) / (kExt * muInt)

# Boundary conditions

def evalIncDirichletTrace(point, normal):
    field = evalIncField(point)
    result = np.cross(field, normal, axis=0)
    return result

def evalIncNeumannTrace(point, normal):
    x, y, z = point
    curl = np.array([x * 0., -1j * kExt * np.exp(1j * kExt * x), x * 0.])
    result = np.cross(curl / (1j * kExt), normal, axis=0)
    return result

def evalIncField(point):
    x, y, z = point
    field = np.array([x * 0., y * 0., np.exp(1j * kExt * x)])
    return field

# Load mesh

grid = createGridFactory().importGmshGrid(
    "triangular", "../../examples/meshes/sphere-ico-4.msh")

# Create quadrature strategy

accuracyOptions = createAccuracyOptions()
# Increase by 2 the order of quadrature rule used to approximate
# integrals of regular functions on pairs on elements
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(2)
# Increase by 2 the order of quadrature rule used to approximate
# integrals of regular functions on single elements
accuracyOptions.singleRegular.setRelativeQuadratureOrder(2)
quadStrategy = createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

# Create assembly context

assemblyOptions = createAssemblyOptions()
assemblyOptions.switchToAcaMode(createAcaOptions())
context = createContext(quadStrategy, assemblyOptions)

# Initialize spaces

space = createRaviartThomas0VectorSpace(context, grid)

# Construct elementary operators

slpOpExt = createMaxwell3dSingleLayerBoundaryOperator(
    context, space, space, space, kExt, "SLP_ext")
dlpOpExt = createMaxwell3dDoubleLayerBoundaryOperator(
    context, space, space, space, kExt, "DLP_ext")
slpOpInt = createMaxwell3dSingleLayerBoundaryOperator(
    context, space, space, space, kInt, "SLP_int")
dlpOpInt = createMaxwell3dDoubleLayerBoundaryOperator(
    context, space, space, space, kInt, "DLP_int")
idOp = createMaxwell3dIdentityOperator(
    context, space, space, space, "Id")

# Form the left- and right-hand-side operators

lhsOp00 = -(slpOpExt + rho * slpOpInt)
lhsOp01 = lhsOp10 = dlpOpExt + dlpOpInt
lhsOp11 = slpOpExt + (1. / rho) * slpOpInt

lhsOp = createBlockedBoundaryOperator(
    context, [[lhsOp00, lhsOp01], [lhsOp10, lhsOp11]])

# Construct the grid functions representing the traces of the incident field

incDirichletTrace = createGridFunction(
    context, space, space, evalIncDirichletTrace,
    surfaceNormalDependent=True)
incNeumannTrace = createGridFunction(
    context, space, space, evalIncNeumannTrace,
    surfaceNormalDependent=True)

# Construct the right-hand-side grid function

rhs = [idOp * incNeumannTrace, idOp * incDirichletTrace]

# Initialize the solver

precTol = 1e-2
invLhsOp00 = acaOperatorApproximateLuInverse(
    lhsOp00.weakForm().asDiscreteAcaBoundaryOperator(), precTol)
invLhsOp11 = acaOperatorApproximateLuInverse(
    lhsOp11.weakForm().asDiscreteAcaBoundaryOperator(), precTol)
prec = discreteBlockDiagonalPreconditioner([invLhsOp00, invLhsOp11])

solver = createDefaultIterativeSolver(lhsOp)
solver.initializeSolver(defaultGmresParameterList(1e-8), prec)

# Solve the equation

solution = solver.solve(rhs)
print solution.solverMessage()

# Extract the solution components in the form of grid functions

extDirichletTrace = solution.gridFunction(0)
extNeumannTrace = solution.gridFunction(1)

scattDirichletTrace = extDirichletTrace - incDirichletTrace
scattNeumannTrace = extNeumannTrace - incNeumannTrace

intDirichletTrace = extDirichletTrace
intNeumannTrace = extNeumannTrace / rho

# Prepare to evaluate the solution on an annulus outside the sphere

# Create the potential operators entering the Green's representation formula

slPotInt = createMaxwell3dSingleLayerPotentialOperator(context, kInt)
dlPotInt = createMaxwell3dDoubleLayerPotentialOperator(context, kInt)
slPotExt = createMaxwell3dSingleLayerPotentialOperator(context, kExt)
dlPotExt = createMaxwell3dDoubleLayerPotentialOperator(context, kExt)

# Create a grid of points

nPointsX = 201
nPointsY = (nPointsX * 2) // 3
# x, y, z = np.mgrid[-5:5:nPointsX*1j, -5:5:nPointsY*1j, 0:0:1j]
x, y, z = np.mgrid[-2:4:nPointsX*1j, -2:2:nPointsY*1j, 0:0:1j]
points = np.vstack((x.ravel(), y.ravel(), z.ravel()))

# Split the points into those located inside and outside the scatterer

inside = areInside(grid, points)
outside = np.logical_not(inside)

# Use appropriate Green's representation formulas to evaluate the total field
# inside and outside the scatterer

evalOptions = createEvaluationOptions()
# Evaluate field (all three components) at exterior points
valsExt = (- slPotExt.evaluateAtPoints(scattNeumannTrace,
                                       points[:,outside], evalOptions)
           - dlPotExt.evaluateAtPoints(scattDirichletTrace,
                                       points[:,outside], evalOptions)
           + evalIncField(points[:,outside]))
# Calculate field magnitude
valsExt = np.sqrt(valsExt[0].real ** 2 + valsExt[0].imag ** 2 +
                  valsExt[1].real ** 2 + valsExt[1].imag ** 2 +
                  valsExt[2].real ** 2 + valsExt[2].imag ** 2)
# Evaluate field (all three components) at interior points
valsInt = (  slPotInt.evaluateAtPoints(intNeumannTrace,
                                       points[:,inside], evalOptions)
           + dlPotInt.evaluateAtPoints(intDirichletTrace,
                                       points[:,inside], evalOptions))
# Calculate field magnitude
valsInt = np.sqrt(valsInt[0].real ** 2 + valsInt[0].imag ** 2 +
                  valsInt[1].real ** 2 + valsInt[1].imag ** 2 +
                  valsInt[2].real ** 2 + valsInt[2].imag ** 2)

# Combine the results obtained for points inside and outside the scatterer
# in a single array

vals = np.empty(nPointsX * nPointsY, dtype=complex)
np.place(vals, outside, valsExt.ravel())
np.place(vals, inside, valsInt.ravel())

# Display the field plot

from bempp import visualization as vis
uActor = vis.scalarDataOnRegularGridActor(
        points, vals, (nPointsX, nPointsY))
legendActor = vis.legendActor(uActor)
gridActor = vis.gridActor(grid)
vis.plotTvtkActors([uActor, gridActor, legendActor])

# Export the results into a VTK file

from tvtk.api import write_data
write_data(uActor.mapper.input_as_data_set, "u.vts")
